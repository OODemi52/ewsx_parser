# EasyWorship Scripture Schedule Parser Challenge

## Overview
This project is designed as a learning challenge for software engineers of all kind. The goal is to create an application that allows users to upload message outlines containing Bible verses, which the application should then parse out the verses and structure them into an [EasyWorship](https://www.easyworship.com) schedule file (`.ewsx`) that the user can download and use directly in [EasyWorship](https://www.easyworship.com).

This project was the result of an actual need I, as well other people in my life had (the best projects and products usually are), and so I have deployed my implementation of this project, and you can find it on the side bar thingy on GitHub, or by just clicking [here](google.com).

## Project Requirements
- **Input File**: Users should be able to upload a file containing message outlines with Bible verses. In this context, a message outline is a document written by a preacher/minister/pastor/bishop/clergy etc. that outlines the message that they will preach about. Sort of like the thing they teach you to do in English classes, that everyone just ignores and jumps to writing the actual paper instead. This outline will have references to Bible verses in a format similar to [`John 3:16`](https://www.biblegateway.com/passage/?search=John%203%3A16&version=NIV), [`1Cor13.13`](https://www.biblegateway.com/passage/?search=1%20Corinthians%2013%3A13&version=NIV), or [`2 Kings 2:23-24`](https://www.biblegateway.com/passage/?search=2%20Kings%202%3A23-24&version=NIV), and are sometimes accompanied by translation abbreviations such as [`AMP`](), [`NIV`](), or [`NKJV`](). Example outlines are provided in the `data/examples/outlines/` folder.
- **Output File**: The application should generate a valid [EasyWorship](https://www.easyworship.com) schedule file, `.ewsx`, that can be downloaded and loaded into [EasyWorship](https://www.easyworship.com).
- **Parsing**: The application must accurately parse Bible verses from the input file. Parsing is a very well understood problem, and is one that is fundamental to software engineering, and computer science as a whole. I wont provide any information about how to parse, but if you are looking for a more software focused project to do involving parsing, you should try [Crafting Your Own Interpreter](https://craftinginterpreters.com/contents.html).
- **Validation**: Ensure the generated `.ewsx` file is valid and can be imported into [EasyWorship](https://www.easyworship.com) without errors.
- **Documentation**: Include comprehensive documentation on how to use your application, as well as your thought process and implementation details.
- **Testing**: Ensure your application is thoroughly tested and works as expected. Along with example outlines being provided in the `data/examples/outlines/` folder, there are example `.ewsx` schedule files in the `data/examples/schedules/` that correspond to each outline by name. You can use these to test and compare the `.ewsx` schedules your application generates.
- **No External Dependencies**: The solution should not rely on external APIs, services, or solutions for parsing the scriptures or generating the `.ewsx` schedile files. Not saying that they do existüòâ but if they do, don't use them lol. This project is about learning!
- **Compatibility**: The application should be compatible with the latest version of [EasyWorship](https://www.easyworship.com).


## The Challenges
- **No External APIs**: [EasyWorship](https://www.easyworship.com) does not have an API for interacting with its features. This means you will have to figure out how the `.ewsx` schedule file type works on your own. While I don't want to give away any hints, attention to detail and research are key here. [EasyWorship](https://www.easyworship.com) is production software that was intially launched in 2006. That's a long time ago! This means that unlike most project tutorials you'll find online, things may not be so straightforward when coming up with your solution, so you need to test things out and ensure you code works the way you think it works.
- **Parsing Can Be Tricky** - Parsing is somewhat complex and theory heavy subject that can be difficult to grasp, especially if you are not very familiar with [Data Structures and Algorithms](https://www.techinterviewhandbook.org/algorithms/study-cheatsheet/), but is not impossible ( when it comes to writing software virtually (badum-tss) nothing is impossible if you're willing to stare at a screen for long enough). It is also a veeeeeery well documented, analyzed, explained, optimized, tutorial-ized, etc. process, so while it might present you with a challange, I have faith that you can do it! (see [`Phil 4:6 NKJV`](https://www.biblegateway.com/passage/?search=Philippians%204%3A13&version=NKJV))
- **No Support for ARM**: [EasyWorship](https://www.easyworship.com) is a very beloved software to me, but it is an old piece of software and the client base is not really young and hip kids that complete projects they read about on Github in their free time. The [EasyWorship](https://www.easyworship.com) software is only currently being supported on devices on toting [x86 or x86-64](https://support.easyworship.com/support/discussions/topics/24000017633) architecture on Windows machines. If you dont know the difference between ARM and x86 architectures, or even why the word "architecture" is being used in a project that supposed to be about programming, it's worth a quick read, and will probably help you under stand your machine a little better. With the growing popularity of the ARM architecture, this means that you wont be able to run the [EasyWorship](https://www.easyworship.com) software on your spec'd out [$8000 M4 Max Macbook Pro](https://www.apple.com/shop/buy-mac/macbook-pro/16-inch-space-black-standard-display-apple-m4-max-with-16-core-cpu-and-40-core-gpu-48gb-memory-1tb#) (if your feeling generous, just max out the specs at checkout for me and I'll let you know where to send itü•π) or your shiny new [ThinkPad](https://www.lenovo.com/us/en/p/laptops/thinkpad/thinkpadp/thinkpad-p1-gen-7-16-inch-intel/21kv001cus?orgRef=https%253A%252F%252Fwww.google.com%252F&cid=us:sem%7Cse%7Cgoogle%7Cp_series_intel%7Cgs_notebooks%7C%7C21KV001CUS%7C6548549653%7C76751676937%7Cpla-2380496801910%7Cshopping%7C&gad_source=1&gbraid=0AAAAADnnO-U_55XXkT7DaNHyB2yaHZ_ns&gclid=CjwKCAiAw5W-BhAhEiwApv4goMAJmm9cZ0fm63blr1DxFriq49kOt0iBWm_9NlmpclhSIJ_8CwxooRoC7VIQAvD_BwE) that you immediately flashed [Arch Linux](https://archlinux.org) onto because all the [cracked](https://www.urbandictionary.com/define.php?term=Cracked) Twitter micro-celebrities keep posting about it to boost their engagement. But not to worry, I have built and hosted a virtual machince running Windows with the EasyWorship software installed for you to use in this project. There, you can try out the software as well as test to see if the  `.ewsx` schedile files your app makes work. You can find it here: [VeeasyWorship](www.google.com)

## Implementation Details
- **Language Agnostic**: Write this project in whatever language you feel like. You can choose your favorite language, use this as opportunity to learn a new one, or even mix them together. The problem this project solves should be agnostic to your implementation, meaning that the user should not have to worry or care how your app works - as long as it actually works. So any language(s) you decide to use, from Ada to Zig (I promisre these are real programming languages, and not made up words), are fine with me!
- **Full End-to-End Solution**: Users should be able to upload a file and receive a working [EasyWorship](https://www.easyworship.com) `.ewsx` schedule file in return, with no additional steps required on their end. How that's implemented is solely up to you.
- **Scriptures Tab Only**: This project focuses only on the Scriptures tab of EasyWorship. No songs, presentations, or other media elements should be included. If you're unfamiliar with it, then looks like you have some research to do! (Hint: play around with [EasyWorship](https://www.easyworship.com) here: LINK TO HOSTED VM RUNNING EASYWORSHIP)
- **Documentation and Testing**: Developers should document their thought process and implementation details to help others learn from their approach.
- **Version Control**: Try maintain healthy [Git Hygiene](https://dzone.com/articles/developer-git-commit-hygiene-1). This is an important skill to have as a software engineer, and if you end up messing up any part of your application, you'll thank yourself if you are able to go back to a version that works. Sometimes `Ctrl-Z` is not enough! 

## ‚ú®Bonus Points‚ú®:
  - Develop a  [Well-Designed UI](https://www.uxpin.com/studio/blog/ui-design-for-developers/) for users to interact with. This is your chance to show me (and any recruiters looking at your resume üëÄ) not only that you know how to type some keys on a keyboard, but also that you care about the experience that your user/customer has when using the software that you have created.
  - Try hosting the application online so others can use it without local setup. This will look good on your portfolio, but if you do make sure you set your server up properly. You need to take a lot of things into consideration, but here are what I consider to be among the most important:
    - **Security** - Users will be using your application and uploading their data to it. Make sure that it is secure as you can possible make it. If you are well versed in information security already, or even if you are, this is a great opportunity do some research into [Web Securirty Principles](https://mlhale.github.io/nebraska-gencyber-modules/intro_to_first_principles/README/) and [API Security Best Practices](https://sandydev.medium.com/6-best-practices-for-securing-backend-apis-from-common-vulnerabilities-a-comprehensive-2023-guide-cd15d5225b1f)

    -  **Validation** - This also falls under security, but is about the security of you own application. Anything that is accepted by your server should be check and verified that it is what it says it is. Notice that I mentioned that an outline is a document, but I didn't specify what type of file one should/can be. That's up to you and the use use case you attempt to address with your app implementation. But whatever file types you accept, you prooobbably want to check and make sure it is that file type, that is [Validate Your Input](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html).
    
    - **Abuse** - Unlike what we are all definetly taught while growing up, not everyone on the internet is a good, trustworthy person, who would never act maliciously toward you. Shocking! creating an application of any sorts comes with the inherent risk of someone abusing that software. This can manisfest in the form of an end user clicking a button 100 times because they are impatient, someone DDOSing your sever because they're yor sworn enemy, or simply because you wrote a while loop and didn't provide a exit condition, and now that [fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch) function you wrote has be called one thousand times in the past minute. It's very important to set up safeguards to avoid abuse, malicious or otherwise, in your application. I again do not want to give to much input in your implementation of the project, but [Rate Limiting](https://www.cloudflare.com/learning/bots/what-is-rate-limiting/#:~:text=Rate%20limiting%20is%20a%20strategy,reduce%20strain%20on%20web%20servers.), [Authentication](https://dev.to/ma7moud3bas/how-to-secure-the-web-a-comprehensive-guide-to-authentication-strategies-for-developers-48od), and [Proxying](https://developers.cloudflare.com/learning-paths/prevent-ddos-attacks/baseline/proxy-dns-records/) are examples of some of that way you can mitigate the risk of [API Abuse](). Again, I do not want to hijack your learning experience, but the [Cloudflare Free Tier](https://www.cloudflare.com/plans/free/) offers some services that would be a good starting point for securing your application, regardless of what platform you choose to host your application on.
    
    - **Server Cost** - *** ***IF YOU DON'T READ ANY OTHER OF THE OTHER CONSIDERATIONS, READ THIS ONE*** ***. Hosting platforms and server providers come in all shapes and sizes. In the effort to give you as much agency as possible in this project, I am fighting every urge to suggest what platforms I would personally recommend you to use. But which ever you do end up using, and I can't stress this enough, **UNDERSTAND HOW THE PRICING WORKS!!!** You can find many [Horror Stories](https://cybernews.com/news/ddos-attack-104k-bill-from-hosting-provider/) of engineers waking up to find out the website the innocently hosted of the platform of their choosing's free tier, has magically generated a humongous bill for them overnight. Most, if not all, hosting service providers have ways for you to either limit how much you can spend, or monitor how much your bill at the end of the month will be and set alerts when the amount goes past a certain threshold (but if your smart, or ‚ú® *financially challenged*‚ú® like I an at the moment, you'll figure out a way to host it for $Free.99).

## Getting Started
1. Clone this repository and [create a new git branch](https://www.w3schools.com/git/git_branch.asp?remote=github) for yourself to develop your application in.
2. Develop your solution to parse Bible verses from message outlines and convert them into an `.ewsx` schedule file.
3. Document your process, including any challenges and how you solved them. You never know who you might end up helping!
     - If you complete a working solution, consider hosting it online for others to use.

### Testing in EasyWorship
Since [EasyWorship](https://www.easyworship.com) does not support ARM or non-Windows machines, testing can be a challenge unless you have a computer that meets the criteria (I say this as someone who does not have a computer that meets that criteria. To address this, I have hosted and deployed.

### Submit Your Solution
You can submit your solution for others to see. As an engineer, you have to be both confident in your work but also willing to accept your wrong or don't know something (it will be like this for as long as you live - engineers are life long learners!). If I have time, I might even try and review your solution

4.
- [Switch](https://git-scm.com/docs/git-checkout) to the `solutions` Git branch.
- Submit a pull request to the `solutions` branch.


## Final Considerations
1. You will probably struggle with this project, and depending on who you are an what you want, that might be okay. If you're looking for a quick and easy project to fluff your portfolio, **this might not be the one for you**. There is *intetionally* no guide for this, no tutorial, and it is a project based on software that is not popular, so there is not much written about it. If, on the other hand, you're looking for a bit more of a challenge, want to learn more, improve/sharpen your skills, or are just someone that really likes EasyWorship, then you've come to the right place! **You will still struggle** but that process of struggling throught the problem is **CRUCIAL** to learning deeply

***
### **‚ö†Ô∏èWarning‚ö†Ô∏è**
The following section gets ***very*** rant-y so if you don't want to hear it, just skip it, it is in no way necessary to completeing the challange. Butttttt I think it is an important topic (that's why I spent so much time researching writing it!) and I tried my best to make it a good read. Well, if your still here, that's on you. Proceed witht the ranting!
***

2. Listen - I can't tell you how to live your life, especially not through a computer screen, but I sure can try: **DO NOT USE CHATGPT TO SOLVE THIS**, or any other quoute-unquote "AI" chatbots or tools. Seriously. No I am not joking. What we have all come to know as "AI", or more specifically ***Generative AI***, encompasses a litany of tools that work like seemingly like magic. But whenever something seems like its operating under unknown systems of magic, as I've come to learn time and time again ever since I took STAT355 in undegrad, that there is a high probability (badum-tss again!) that it's just statistics and some complex algebra/calculcus applied in very complex ways, by complex genius' who get their joy in life from doing complex math (just like I do, not that I'm a genius just yet). Bet you wish you payed more attention in your stats class now, huh? "AI" is reallllly cool and can be really helpful in so many areas of everyday life. Learning, however, is one area you have to be very careful in using LLM's to try and assist you, and that for a few reasons:
    1. **"AI" tools don't actually *"know"* anything** - I don't care what you've heard, what they said in the news, or what Sam Altman has been spouting on Twitter to get more of that sweet, sweet, VC-cash. [LLMs Do Not *Really* "Know" or "Understand" Anything](https://www.linkedin.com/pulse/large-language-models-do-understand-anything-here-why-ter-danielyan-djube) and [Can Not Think or Reason](https://pub.towardsai.net/apple-llms-cannot-reason-acdaeab9b796) (when I say reason, I do not mean like what models like O1/R1/O3 can do, which is also very impressive, but [Still Is Not "*Actual*" Reasoning](https://www.vellum.ai/reasoning-models)). For a deeper, slightly more-than half-baked, analysis of what AI/LLM systems are actually doing, if not thinking or reasoning, skip down to point **`v.`** This, in and of itself, is not an issue. But when the technology is presented as the super-intelligence our species has been striving towards for decades and can't handle simple things like consistently alerting user when it [Does Not Know](https://archive.ph/XKG86) something.... well now we have an issue. The estimates about how often LLMs "hallucinate", or as I like to call it - *bullshit* - are all over place. But it seems like [Completly Eliminating Hallucinations](https://arxiv.org/abs/2409.05746#) is something will probably never happen, and the larger the models get, which they need to get a loooot larger to take us to the glorious utopia of "AI" stealing all our jobs, [The More They Seem To Lie](https://decrypt.co/283516/bigger-ai-models-lie). This is not because there aren't smart people working on that problem, but because of the fundamental limitations of the [LLM model architecture](https://www.linkedin.com/posts/andriyburkov_hallucinations-in-llms-are-by-design-its-activity-7139826906773778432-WtGZ).
    2. **Using "AI" Without Safeguards Causes Over Reliance** - Again, if you're not really in it to learn, and learn deeply, you can just skip this point. But there is some. Since the meteroic rise of ChatGPT, many people have began to use it to assist them in programming. Many people also have realised that "AI" is having serious negative effects on their programming skills. This group of people ranges far and wide, from noobs like to me, to pros like [The Guy-Who-Worked-At-Netflix-BTW-agen](https://www.youtube.com/c/theprimeagen). As he has pointed out, quite consistently I might add, we are [22 Months Into 6 Months Away From AI Taking Our Jobs](https://x.com/ThePrimeagen/status/1879934206157156504). But he, as well as I and many others have realized that the more we use tools like ChatGPT and Copilot, the more we rely on them (duh). Which would be fine if AI was perfect. But it is frankly not perfect, not by a long shot. I can't count how many times I have asked ChatGPT about a external package, only to be met with methods that don't exist, and have never existed, with it doubling down when I try to prompt it towards the actual package implementation. And this usually just ends up with me going to find the real documentation and getting the solution I need within 3.7 minutes of me reading it. Relying on a system that is routinely wrong but doesn't know how to admit it, [Can't Keep Track Of Itself or What It Has Been Doing For Long Periods Of Time](https://sean-warman.medium.com/why-cant-ai-remember-anything-82f045320496), and doesnt truly understand what it's being asked is a recipe for disaster. All the while, you forget how to do basic things like properly debug errros, or catch sneaky bugs, or maybe you never learned those things, and never will be cause you feel like you [Can't Code Without "AI"](https://www.reddit.com/r/AskProgramming/comments/1e4wokc/i_feel_like_i_cant_code_without_ai/). When over relying on LLMs to help you code, you seriously stunt your growth, and worse put yourself in the rough position of not actually knowing what your doing, which can come back to blow up in your face in spectacular ways.
    3. **"AI" Makes Your Code Worse** -  But in the mean time, a [loooot](https://github.blog/news-insights/research/survey-ai-wave-grows/) of AI code is being generated, and... well, the [Quality of That Code](https://www.gitclear.com/coding_on_copilot_data_shows_ais_downward_pressure_on_code_quality) is cause for discussion at the very least, if not for outright concern. Think about the process when you write code. It's more than just the typings, more than the copy and pasting, there various things going on in your brain as you code. One of those very important process is you building a sort-of a *mental map* of the code you're writing, and the codebase it lives in. Due to context window limitiations, AI chats can only last for so long, before it gets to the point where the code the LLM is generating isn't as magical anymore It starts to forget details and lines, it misunderstands what you ask it to do, and starts making things up. Ok, easy fix - you start a new chat and continue from there. But wait just one minute! You left all it's context behind. Now when you go to that new chat, the code it generates might still be similar, but there will be subtle changes to how it outputs code for you, in structure, style, [smell](https://www.sonarsource.com/learn/code-smells/), and syntax. These changes can be harmless, especially in small codebases, but when your code bases start to grow to medium to largish size... just take take my word for it, I have [Embarrasingly Prompted My Way Into That Corner Before](https://github.com/OODemi52/slackUpload) and I am still paying the price in code rewrites and refactors. And when this happens, you run into another unfornate pitfall - like i said earlier you left all "it's" context, as in the chats context, behind. While you may have built somewhat of a mental map, it is shallow and easily forgettable since it wasn't etched into of your brain by way of thoughtfully putting finger to key, and any pathways that were formed didn't undergo the [Myelination](https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://www.nature.com/scitable/topicpage/myelin-a-specialized-membrane-for-cell-communication-14367205/%23:~:text%3DMuch%2520like%2520the%2520insulation%2520around,(known%2520as%2520action%2520potentials).&ved=2ahUKEwiWnpPb_--LAxXzF1kFHUM_HYEQFnoECCAQAw&usg=AOvVaw1zxLkg_rTkeAQKZdcmvq6_) the result from painstakingly reading the scary red letter that sometimes show up in your terminal when you press the play button in VSCode, and understand what they mean and how to make the truly go away.
    4. **"AI" Can Promote Learned Helpness"** - This is a sneaky one, but relates to what I've already said in points **`ii.`** and **`iii.`**. When you take the easy way out, like in the last example I gave of not debugging errors on your own, you slowly start to teach yourself to be helpless. Let me explain. When instead of doing the work yourself, you pass it off to you favorite LLM buddy, a process succinctly described as [Cognitive Offload](https://watchsound.medium.com/from-learned-dependence-to-learned-helplessness-effects-of-cognitive-offloading-in-the-ai-era-e0bc63b41dbe) you strengthen, or myelinate (I know this is my second time using this word, but I just like how it sounds lol) the pathways in your brain that are used in passing of the work to someone/something else, rather than the pathways used to solve problems. It's the price you pay for and immediate solution. On its own, asking Claude to fix one things for your seems insignificant - and thats because it is. But the issue is that it compounds, and quickly. It's like credit card debt, the more you let it build up, worse it gets. This so called debt increase at an exponetial rate, with a rise so step that you might now know when it get bad. And the interest rate for this particular credit card is very high. You end up ***rapidly*** teaching yourself that when I come across a hard problem, the first thing I should do is see if something else can solve it. You teach yourself, subconsiously, that you are not very capable of solving hard problems. And the more you do it, those more neural pathways are reinforced, and the harder it is to get out of that loop. I was there at some point. I had completly forgetton how to right Javascript arrow functions before I realized - which were created to be more concise and readable. Even though I would see them in my code all the time, even though ChatGPT, or Copilot, Perplexity, or whatever would generate them all the time, they were always in my face, under my nose, at the tip of my fingers. But the one place they weren't anymore, was in my mind. If you don't believ me, try it for yourself. Without the use of "AI", try and create a simple program that formats a given time duration (in seconds, minutes, hours, whatever you want) into a human-readable string representation. Odds are, you'll figure it out. But if you've been using "AI" to code a lot, pay attention to the urges you get while doing this. And if you get stuck, pay attention to how your mind tries to get you to solve the problem.
    5. **Bonus - 4 A.M. Explanation of How LLMs Actually Work** - ***üöß Under Constructionüöß Its late and I have work to do so I will come back and finish this later! There are also probably tons of errors in this file, but I promise to go through it later this week and hopefully fix any that remain.***

All-in-all, LLMs are not the devil. They can be actually very useful, but the suffer from 1 huge issue - they are hyped up to be the final coming of "AI" and the end of software engineering. The AI tools are presented as living, thinking, beings that know everything. When in reality, they are huge statistical computers that excel at predicting what words is supposed to come next like some kind of beefed up autocorrect. 

But that's kind-of it. 

They may seem to magically do things like think, understand, and recall information, but that's because that's what they were designed for - not to actually do all those things that I just listed, but to **<ins>seem</ins>** like they are doing those things. I have no problem with admitting that the lines do get blurred because LLMs often feel or seem seem "correct" ([this is somewhat of a philisophical question](https://scottambler.com/llms-always-hallucinate/)), but that's part of the problem, since what they are trained to do best is just to seem to be correct, even when they are not! 

Online, you might come across threads of people going back and forth about what exactly consitutes "thinking" and if there is a line between seeming like you can think and actually thinking - and if we would even be able to tell. It's a fascinating conversation and it raises a lot of questions, and points at the fact that we really truly don't have a clear-cut definition of thinking. We also don't know exactly what is going on inside LLMs when they process queries, and there might even something to say about [LLMs Mimicing Brain Function](https://www.quantamagazine.org/how-ai-transformers-mimic-parts-of-the-brain-20220912/) - at least in part. But these conversations often miss out on a lot of the nuance that we do understand about [Thinking In Human Beings Compared To LLMs ](https://www.adiuvo.org.uk/post/unreasonable-ai---the-difference-between-large-language-models-llms-and-human-reasoning).

It would help to remember that when you ask Chat (short for ChatGPT) a question, it is not thinking. Like, not even a little bit. Even those times when it takes a long time or is "reasoning". It was designed to sound as much like a human being as it can, and the byproduct of it being trained such MASSIVE amounts of human readable text to do that is that it also seems to be very knowledgeable at times. But with a sizeable chunk of the entire corpus of the internet used to train these models, one would hope that it wouldn't lie so much. 

And don't let people fool you, this is a hug problem for "AI". It's the reason that even though they tell us to buckle up and be ready to loose our jobs, they desperatly want us to use their new shiny "AI" tool. It's the a big part of the reason [RAG](https://aws.amazon.com/what-is/retrieval-augmented-generation/) as a concept exists, and even with that it is still hard to get the LLMs to consistently behave properly.

I don't think you should not use "AI" tools at all, on the contrary, I think the way the job market for engineers is moving, knowing how to use LLM tools properly will be able to indispensable skills, but we must be aware of the pitfalls, and learn resposible ways of using these tools, so we our capacities to think aren't comepletly nerfed into the ground.

These tools will absolutely get better, but so should you, and those two things are not diametrically opposed to one another, but "AI"'s improvement is backed by thousands of engineers and billions - probably soon to be trillions in the future - of dollars. And unfortunately for you, your future is in your own hands! So you have to back yourself up as much as possible as well. And I think this "small" project can be a good way to detox from the ever-addicting death-drive that is currently being euphemised as ["Vibe-Based Engineering"](https://news.ycombinator.com/item?id=43169706). Yuck.

If you still decide to use "AI" to solve this challenge, I actually think that there's no issue in that. But I urge you to be mindful of your use of it, validate what its tellinng with real world facts, and still try to do things that frustrate you on your own.

But if you can resist the urges, as I will also try to do when coming up with my own solution to this problem, you'll come out of it a much better engineer. And I'll be proud of you if that counts for anything.

P.S. This was written on March 4, 2025 (I hate when articles aren't dated, how am I supposed to know how old the information is without that!). Also this might get removed from this README since its so unrelated, so if youre currently go through the git history and its gone, hi!üòõ

## License
This project is open-source under the MIT license and intended for educational purposes.

Happy coding!

